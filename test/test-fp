#!/bin/bash
#+============================================================================
#
# Description:
#
#   Calculate dispersion using a NWP forecast
#   -----------------------------------------
#
#   Checks files on disk and retrieves them from cache or store
#   Creates input and output directories for flexpart
#   Adapts input files for flexpart
#   Creates numbered job directory
#   Copies executable to job directory
#   Submits job on appropriate queue
#
# Author: Pirmin Kaufmann, MeteoSwiss
#
# Version:
  revision="1.7.1 ifs"  #vincr# version number, may be incremented using vincr
#
# See git log for history of modifications
#-============================================================================

#=============================================================================
# Settings
#=============================================================================
# NWP model data sources
# ----------------------
# Load operational definition of OPR_OPR_DIR
[[ -z $OPR_OPR_DIR ]] && source /oprusers/osm/.opr_setup_dir
# Path to NWP files depending on resolution (see --resol)
# String is split at " in: "
# Template:
#   "<description> in: <file-with-path>"
# Allowed placeholders: <yymmddhh>, <ex>, <ddhh>, <mem>
# (COSMO models not yet supported by this version of test-fp)
# COSMO-1E
nwp_max_range_1e=33
lt_inc_1e=1
nwp_source_list_1e=(
    "Operational LADM cache     in: $OPR_OPR_DIR/cache/LADM/FLEXPART-C1E-CTRL/dispc*"
    "Operational fcst cache     in: $OPR_OPR_DIR/cache/COSMO-1E/FCST_RING/<yymmddhh>_4<ex>/cosmo/<mem>/lfff<ddhh>0000"
    "User cache                 in: /scratch/$LOGNAME/<yymmddhh>_4<ex>/cosmo/<mem>/lfff<ddhh>0000"
    "Cases in user store        in: /store/mch/msopr/$LOGNAME/CASES/COSMO-1E/<yymmddhh>_4<ex>/cosmo/<mem>/lfff<ddhh>0000"
)
# COSMO-2E
nwp_max_range_2e=120
lt_inc_2e=1
nwp_source_list_2e=(
    "Operational LADM cache     in: *** not available ***"
    "Operational fcst cache     in: $OPR_OPR_DIR/cache/COSMO-2E/FCST_RING/<yymmddhh>_5<ex>/cosmo/<mem>/lfff<ddhh>0000"
    "User cache                 in: /scratch/$LOGNAME/<yymmddhh>_5<ex>/cosmo/<mem>/lfff<ddhh>0000"
    "Cases in user store        in: /store/mch/msopr/$LOGNAME/CASES/COSMO-2E/<yymmddhh>_5<ex>/cosmo/<mem>/lfff<ddhh>0000"
)

# Legacy models
# COSMO-1
nwp_max_range_1=33
lt_inc_1=1
nwp_source_list_1=(
    "Operational LADM cache     in: *** no longer available ***"
    "Operational fcst ring      in: *** no longer available ***"
    "User cache                 in: /scratch/$LOGNAME/<yymmddhh>_1<ex>/lm_coarse/lfff<ddhh>0000"
    "Cases in user store        in: /store/mch/msopr/$LOGNAME/CASES/COSMO-1/<yymmddhh>_1<ex>/lm_coarse/lfff<ddhh>0000"
)
# COSMO-E
nwp_max_range_e=120
lt_inc_e=1
nwp_source_list_e=(
    "Operational LADM cache     in: *** no longer available ***"
    "Operational fcst ring      in: *** no longer available ***"
    "User cache                 in: /scratch/$LOGNAME/<yymmddhh>_2<ex>/lm_coarse/<mem>/lfff<ddhh>0000"
    "Cases in user store        in: /store/mch/msopr/$LOGNAME/CASES/COSMO-E/<yymmddhh>_2<ex>/lm_coarse/<mem>/lfff<ddhh>0000"
)

# ECMWF models for use with flexpart-ifs
# ECMWF IFS-HRES Europe
nwp_max_range_f=92
lt_inc_f=1
nwp_source_list_f=(
    "Operational LADM cache     in: $OPR_OPR_DIR/cache/LADM/FLEXPART-IFS-EUROPE/dispf*"
    "User cache                 in: /scratch/$LOGNAME/FLEXPART-IFS-EUROPE/disp*"
    "Cases in user store        in: /store/mch/msopr/$LOGNAME/CASES/IFS-HRES_Europe/dispc*"
)
# ECMWF IFS-HRES global
nwp_max_range_g=144
lt_inc_g=3
nwp_source_list_g=(
    "Operational LADM cache     in: $OPR_OPR_DIR/cache/LADM/FLEXPART-IFS-GLOBAL/disp*"
    "User cache                 in: /scratch/$LOGNAME/FLEXPART-IFS-GLOBAL/disp*"
    "Cases in user store        in: /store/mch/msopr/$LOGNAME/CASES/IFS-HRES_global/disp*"
)

# command used to launch an executable for your particular scheduler, e.g. srun, mpirun, etc
[[ -z ${srun_cmd} ]] && srun_cmd="srun --kill-on-bad-exit"
# command used to submit a job to your particular scheduler, e.g. sbatch, qsub, etc
[[ -z ${sbatch_cmd} ]] && sbatch_cmd="sbatch"
# path to landuse_file 
[[ -z ${landuse_file} ]] && landuse_file="/store/mch/msopr/flexpart_data/IGBP_int1.dat"

# Flexpart environment file
environment_file=$(dirname $PWD)/src/FLEXPART.env
# Flexpart input file templates
input_templates=$(dirname $PWD)/options # original options directory
# File for automatic job numbering
job_no_file=$HOME/.flexpart_job
# Root directory for job directories
job_root=$SCRATCH/flexpart/job
# File with additional metadata not in nc file (see also pyflexplot_jobout script)
plot_info_file=plot_info
# Job file name
job_file=job
# Job logfile
job_out=job.log

# Defaults for arguments
# ----------------------
# Base time
basetime=$(date --utc --date="00 yesterday" +%Y%m%d%H)           # Yesterday 00 UTC
# Forecast range (automatically reduced if > max_range)
fc_range=48
# Simulation mode
mode=1

# Defaults for options
# --------------------
# Resolution (-r, --resol)
resol=f
# Ensemble members (-m, --member)
member=000
# Flexpart executable (-e, --exe-tag)
# should agree with Makefile variables EXEDIR, EXECUTABLE
exe_path=$(dirname $PWD)/src
fp_exe_serial=FLEXPART
fp_exe_parallel=FLEXPART_MPI
# Flexpart option (--fp-opt)
# one of -v, -v2, -i, -i2, and argument (name of pathfile)
fp_opt=
# Run mode serial or parallel (--run-mode)
run_mode=serial
# Release start and end (h, relative to basetime) (-t, --rel-time)
t1=0
t2=8
# Averaging interval and output frequency (-a, --average)
avg_h=3
# Species number (--species-no)
species_no=16 # Cs-137
# Total released mass (-M, --rel-mass)
rel_mass=1.0E09
# Partition (-p, --partition)
# one of postproc, pp-long, pp-serial
partition_serial=pp-serial
partition_parallel=postproc
# Output format (-J, --iout)
iout=9
# Tag of RELEASES file (-R, --rel-tag)
rel_tag=goe2
#=============================================================================
# Functions
#=============================================================================
function version {
    # Print script name and revision number on stderr
    cat >&2 << EOF

$tag $revision

EOF
} # function version
#=============================================================================
function usage {
    # Show script usage
    cat >&2 << EOF

Script to prepare and run Flexpart

Usage: $tag [Options] [BASETIME FC_RANGE MODE]

Arguments:

  BASETIME      forecast base date/time (format YYYYMMDDHH, def.: $basetime)
  FC_RANGE      maximum lead time / forecast range (def.: $fc_range)
  MODE          simulation mode: 1 = forward, -1 = backward (def.: $mode)

Options:
  Mandatory arguments to long options are mandatory for short options too.
  -a, --average=H      averaging interval and output freqency of H [hours]
                       (Default: $avg_h)
  -n, --dry-run        print commands without executing them
  -x, --exe=EXE        Flexpart executable including path (default path:
                       $exe_path
                       default names: $fp_exe_serial for serial,
                       $fp_exe_parallel for parallel runs)
  -e, --exe-tag=TAG    executable tag, attach _TAG to name of executable
      --fp-opt=OPT     add option OPT to command line when starting FLEXPART
                       (Default: $fp_opt)
  -h, --help           show this help and exit
  -j, --job=NAME       manually set job name (default: consecutive number)
      --parallel       run parallel code
  -J, --iout=I         Set IOUT to I (1 binary, 9 NetCDF output)
  -p, --partition=P    partition, one of pp (=postproc), debug, normal, dev
  -r, --resol=RESOL    resolution, one of: 1e, 2e, 1, e, f, g; default: $resol
  -M, --rel-mass=M     released mass [Bq] (default: $rel_mass)
  -R, --rel-tag=TAG    release tag, selects file RELEASES.TAG (default: $rel_tag)
  -t, --rel-time=T1,T2 release from T1 to T2 (lead times [hours]).
                       (Default: $t1,$t2)
      --run-mode=MODE  run code in MODE, either serial or parallel
  -S, --source-no=N    select source no N from list of NWP data sources
  -N, --species-no=N   select species no N according to definition
                       in SPECIES directory
  -s, --stop           stop script before starting job (do not submit job)
  -V, --version        output version information and exit

EOF
} # function usage

#=============================================================================
# Initialization
#=============================================================================
tag=$(basename $0)
args="$*"

#=============================================================================
# Parse options and arguments
#=============================================================================
iarg=0
while (( $# > 0 )) ; do
    case "$1" in
	-a | --average*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		avg_h="${1#*=}"
	    else
		(( $# > 1 )) && shift && avg_h="$1"
	    fi
	    ;;
	-e | --exe-tag*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		exe_tag="${1#*=}"
	    else
		(( $# > 1 )) && shift && exe_tag="$1"
	    fi
	    ;;
	-e | --fp-opt*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		fp_opt="${1#*=}"
	    else
		(( $# > 1 )) && shift && fp_opt="$1"
	    fi
	    ;;
	-h | --help)
	    usage
	    exit 0
	    ;;
	-J | --iout*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		iout="${1#*=}"
	    else
		(( $# > 1 )) && shift && iout="$1"
	    fi
	    ;;
	-j | --job*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		job_name="${1#*=}"
	    else
		(( $# > 1 )) && shift && job_name="$1"
	    fi
	    ;;
	-M | --rel-mass*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		rel_mass="${1#*=}"
	    else
		(( $# > 1 )) && shift && rel_mass="$1"
	    fi
	    ;;
	-n | --dry-run)
	    dry_run=yes
	    ;;
	-p | --partition*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		partition="${1#*=}"
	    else
		(( $# > 1 )) && shift && partition="$1"
	    fi
	    [[ $partition == pp ]] && partition=postproc
	    ;;
	-r | --resol*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		resol="${1#*=}"
	    else
		(( $# > 1 )) && shift && resol="$1"
	    fi
	    ;;
	--run-mode*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		run_mode="${1#*=}"
	    else
		(( $# > 1 )) && shift && run_mode="$1"
	    fi
	    ;;
	-R | --rel-tag*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		rel_tag="${1#*=}"
	    else
		(( $# > 1 )) && shift && rel_tag="$1"
	    fi
	    ;;
	-s | --stop)
	    no_submit=yes
	    ;;
	-N | --species-no*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		species_no="${1#*=}"
	    else
		(( $# > 1 )) && shift && species_no="$1"
	    fi
	    ;;
	-t | --rel-time*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		relt="${1#*=}"
		t1="${relt%,*}"
		t2="${relt#*,}"
	    else
		(( $# > 1 )) && shift && t1="$1"
		(( $# > 1 )) && shift && t2="$1"
	    fi
	    ;;
	-S | --source-no*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		source_no="${1#*=}"
	    else
		if (( $# > 1 )) ; then
		    shift
		    source_no="$1"
		else
		    echo $tag: "Missing value for option: --source-no"
		    exit 1
		fi
	    fi
	    ;;
	-V | --version)
	    version
	    exit
	    ;;
	-x | --exe*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		fn="${1#*=}"
		exe_path=$(dirname "$fn")
		fp_exe=$(basename "$fn")
	    else
		(( $# > 1 )) && shift && exe_path=$(dirname "$1") && fp_exe=$(basename "$1")
	    fi
	    ;;
	*)
	    # Check for unknown option until first positional argument
	    # (some arguments might be negative numbers)
	    if (( $iarg == 0 )) && [[ $1 = -* ]] ; then
		echo $tag: "Unknown option $1"
		exit 2
	    fi
            # Positional arguments
	    (( iarg++ ))
	    case $iarg in
		1)  # BASETIME
		    basetime="$1"
		    # Y2K compatibility for 2000 - 2099
		    [[ ${#basetime} == 8 ]] && basetime=20$basetime
		    ;;
		2)  # FC_RANGE
		    fc_range="$1"
		    ;;
		3)  # MODE
		    mode="$1"
		    ;;
		*)
		    echo $tag: "Too many arguments: $1"
		    exit 3
		    ;;
	    esac
	    ;;
    esac
    shift
done

# Ajust release time and duration
if ! [[ $t1 =~ ^[0-9]+$ ]] ; then
    echo $tag: "Release time 1 not valid: >$t1<"
    exit 4
fi
if ! [[ $t2 =~ ^[0-9]+$ ]] ; then
    echo $tag: "Release time 2 not valid: $t2"
    exit 5
fi

# Check time arguments
eval nwp_max_range=\$nwp_max_range_$resol
eval lt_inc=\$lt_inc_$resol
(( $fc_range > $nwp_max_range )) && fc_range=$nwp_max_range
(( $t1 < 0 )) && t1=0
(( $t1 > $fc_range )) && t1=$fc_range
(( $t2 <= $t1 )) && echo $tag: "Error: Release end before release start: $t2 < $t1"
(( $t2 > $fc_range )) && t2=$fc_range

# Release start and end date/times
release_start=$(date --utc +"%Y%m%d %H%M%S" \
	--date="${basetime:0:8} ${basetime:8:2} ${t1} hours")
  release_end=$(date --utc +"%Y%m%d %H%M%S" \
	--date="${basetime:0:8} ${basetime:8:2} ${t2} hours")

#===============================================================================
# Initialize environment
#===============================================================================

if [[ -z $OPR_OPR_DIR ]] ; then
    echo $tag: "ERROR: Environment variable OPR_OPR_DIR not defined and" \
	"unable to source /oprusers/osm/.opr_setup_dir"
    exit 1
fi

#=============================================================================
# Start processing
#=============================================================================
# Option -n, --dry-run
if [[ -n $dry_run ]] ; then
    # Enable escape sequences in echo with option -e
    exe_cmd="echo -e \e[07;32m \e[0m  "
    echo    $tag: "INFO: Option --dry-run set, printing commands without executing them."
    echo -n $tag: "Skipped commands are marked with: "
    $exe_cmd
fi

# Report arguments
echo $tag: "NWP input base time, range, simulation mode, release tag:" \
    "$basetime, $fc_range, $mode, $rel_tag"
echo $tag: "Release from (lead time, time): +$t1 = $release_start"
echo $tag: "Release to   (lead time, time): +$t2 = $release_end"

# Prepare job
# -----------
# Job number
if [ -f $job_no_file ] ; then
    job_no=`cat $job_no_file`
else 
    job_no=0
fi
if [[ -z $job_name ]] ; then
    (( job_no++ ))
    if [[ -z $dry_run ]] ; then
	echo $job_no > $job_no_file
    fi
    job_name=$job_no
fi
echo $tag: "Job tag: $job_name"

# Option --partition
if [[ -z $partition ]] ; then
    # Default depends on run_mode
    eval partition=\$partition_$run_mode
fi

# Job directory
start_location=$job_root/$job_name
if [ -d $start_location ] ; then
    echo $tag: "Using existing job directory: $start_location"
else
    echo $tag: "Creating job directory: $start_location"
    $exe_cmd mkdir -p $start_location
fi
# Link working dir into test dir
$exe_cmd ln -sf $job_root .

# Executable
if [[ -z $fp_exe ]] ; then
    # Default depends on run_mode
    eval fp_exe=\$fp_exe_$run_mode
fi
if [[ -n $exe_tag ]] ; then
    fp_exe=${fp_exe}_$exe_tag
fi
if [ ! -x $exe_path/$fp_exe ] ; then
    echo $tag: "Executable not found: $exe_path/$fp_exe"
    exit 6
fi
# Copy executable and environmet file
$exe_cmd cp -p $exe_path/$fp_exe $start_location/.
$exe_cmd ln -sf $exe_path $start_location/.
$exe_cmd cp $environment_file $start_location/.

# Input and output directories
flex_input=$start_location/input
flex_output=$start_location/output

# Create pathnames file
echo $tag: "Creating input file: $start_location/pathnames"
# pathnames: directories must have slash at end!
# file must contain empty line at end!
if [[ -z $dry_run ]] ; then
    cat > $start_location/pathnames <<EOF
$flex_input/
$flex_output/
EOF
fi

# Ajust release time and duration
if ! [[ $t1 =~ ^[0-9]+$ ]] ; then
    echo $tag: "Release time 1 not valid: >$t1<"
    exit 7
fi
if ! [[ $t2 =~ ^[0-9]+$ ]] ; then
    echo $tag: "Release time 2 not valid: $t2"
    exit 8
fi

(( $t1 < 0 )) && (( t1 = 0 ))
(( $t1 > $fc_range )) && (( t1 = $fc_range ))
(( $t2 <= $t1 )) && echo $tag: "Error: Release end before release start: $t2 < $t1"
(( $t2 > $fc_range )) && (( t2 = $fc_range ))

# Release start and end date/times
release_start=( $(date --utc +"%Y%m%d %H%M%S" \
	               --date="${basetime:0:8} ${basetime:8:2} $t1 hours") )
  release_end=( $(date --utc +"%Y%m%d %H%M%S" \
	               --date="${basetime:0:8} ${basetime:8:2} $t2 hours") )

# Retrieve NWP input data
# -----------------------

# Select NWP data source
eval nwp_source_list=( \"\${nwp_source_list_${resol}[@]}\" )
if [[ -z $source_no ]] ; then
    echo "Select NWP data source (option --source-no)"
    select answer in "${nwp_source_list[@]}" ; do
	# Note: Press return for default not possible
	# as select repeats prompt until REPLY is not empty
	[[ $REPLY == quit || $REPLY == exit ]] && exit
	# answer is only set if REPLY was valid
	[[ -n $answer ]] && break
    done
    source_no=$REPLY
    echo "You secected: $answer"
else
    (( i_source = $source_no - 1 ))
    answer=${nwp_source_list[$i_source]}
    echo "Selected data source: $answer"
fi

# Extract description and file path from nwp_source_list entry, splitting at "in:"
source_desc="${answer%in:*}"
nwp_source="${answer#*in:}"
# Trim trailing space in source_desc
source_desc="${source_desc%"${source_desc##*[![:space:]]}"}"
# Trim leading space in nwp_source
nwp_source="${nwp_source#"${nwp_source%%[![:space:]]*}"}"

# Nests
# Define start of grib file name of mother and nested domains
case $resol in
    f)
	# Operational configuration summer 2020, mother domain 0.1° Europe, no nest
	nests=( dispf )
	;;
    g)
	# Operational configuration summer 2020, IFS-HRES 0.5° global, 0.1° Europe
	nests=( dispc dispf )
	;;
    h1)
	# Obsolete configuration, IFS-HRES 1° global, 0.1° Europe
	nests=( dispc dispf )
	;;
    h05)
	# Operational configuration, IFS-HRES 0.5° global, 0.1° Europe
	nests=( dispc dispf )
	;;
    h01)
	# Test configuration, mother domain 0.1° Europe, no nest
	nests=( dispf )
	;;
    *)
	echo $tag: "Unknown resolution: $resol"
	exit 4
	;;
esac

# Input location for flexpart
grib_input=$start_location/grib
if [ -d $grib_input ] ; then
    echo $tag: "Using existing FLEXPART input directory: $grib_input"
else
    echo $tag: "Creating FLEXPART input directory: $grib_input"
    $exe_cmd mkdir $grib_input
fi

# Replace placeholders
nwp_search=$(echo "$nwp_source" \
    | sed "s/<yymmddhh>/${basetime:2:8}/g" \
    | sed "s/<ex>/??/g" \
    | sed "s/<ddhh>/[0-9][0-9][0-9][0-9]/g" \
    | sed "s/<mem>/$member/g")
# Check if NWP data is available
nwp_files=( $nwp_search )
nwp_dir=$(dirname $nwp_files)
if [ ! -f $nwp_files ] ; then
    echo $tag: "%ERROR: No matching files found: $nwp_files"
    if [[ $nwp_files == /opr/* && $HOSTNAME != arolla* ]] ; then
	echo $tag: "For current data on /opr try on arolla"
    fi
    exit 7
fi
if [[ $nwp_files == *tgz ]] ; then
    echo $tag: "Unzipping zipped file: $nwp_files"
    gunzip $nwp_files
    nwp_files=( ${nwp_files%.tgz} )
    nwp_dir=$(dirname $nwp_files)
fi

# Report GRIB data directory
echo $tag: "NWP data source: $nwp_dir contains ${#nwp_files[*]} files"
echo $tag: "Supplying input data for FLEXPART in: $grib_input"

# Create input directory, including SPECIES subdirectory
echo $tag: "Creating flexpart input directory: $flex_input"
$exe_cmd mkdir -p $flex_input/SPECIES

# Provide NWP data for flexpart
if (( ${#nwp_files[*]} > $fc_range )) ; then
    # Link NWP data from nwp_files to grib_input
    if [[ -z $exe_cmd ]] ; then
	cp -sf ${nwp_files[@]} $grib_input
    else
	# Abbreviated output for command above, show
	# only first [0] and last [-1] array element
	$exe_cmd cp -sf ${nwp_files[0]}...${nwp_files[-1]} $grib_input
    fi
    $exe_cmd cp -sf $nwp_dir/$grib_const_file $grib_input
else
    echo $tag: "ERROR(4): Insufficient number of files: ${#nwp_files[*]}"
    exit 8
fi

# Create AVAILABLE files
# Loop over nests
i_nest=0
while (( $i_nest < ${#nests[*]} )) ; do
    nest=${nests[$i_nest]}
    if (( $i_nest < 1 )) ; then
	available_filename=AVAILABLE
    elif (( $i_nest < 2 )) ; then
	available_filename=AVAILABLE_NEST
    else
	available_filename=AVAILABLE_NEST$i_nest
    fi
    if [[ -n $dry_run ]] ; then
	available_file=$(tty)
    else
	available_file=$flex_input/$available_filename
    fi
    # Write file header
    echo $tag: "Creating AVAILABLE file with $nest* files for nest $i_nest: $available_file"
    cat > $available_file << EOF
DATE     TIME        FILENAME
YYYYMMDD HHMISS 
________ ______      __________________
EOF

    # Find grib files
    if [ -d $grib_input ] ; then
	pushd $grib_input > /dev/null
	gribfiles=( $nest* )
	if [ ! -e "${gribfiles[0]}" ] ; then
	    echo $tag: "No $nest* files found in: $grib_input"
	    unset gribfiles
	fi
	popd > /dev/null
    else
	echo $tag: "No such directory: $grib_input"
	unset gribfiles
    fi
    # Loop over existing files
    for grib_file in ${gribfiles[*]} ; do
	printf "%s %s0000      %s\n" \
	    ${grib_file:5:8} ${grib_file:13:2} $grib_file >> \
	    $available_file
    done

    # Create pathnames file, entry for each nest
    # pathnames: directories must have slash at end!
    if [[ -z $dry_run ]] ; then
	cat >> $start_location/pathnames <<EOF
$grib_input/
$available_file
EOF

	(( i_nest++ ))
    fi
done # Loop over nests

# Write end of pathnames
if [[ -z $dry_run ]] ; then
    cat >> $start_location/pathnames <<EOF
============================================

EOF
fi

# Create input directory with SPECIES subdirectory
echo $tag: "Creating input directory: $flex_input"
$exe_cmd mkdir -p $flex_input/SPECIES

# Copy input files
echo $tag: "Copying input files from: ${input_templates}"
echo -n $tag: "Copying:"
for f in AGECLASSES RECEPTORS \
	    surfdata.t surfdepo.t ; do
    echo -n " $f,"
    if [ ! -f $input_templates/$f ] ; then
	echo
	echo $tag: "Cannot find template file:" \
	    $input_templates/$f
	exit 10	
    fi
    $exe_cmd cp $input_templates/$f $flex_input
done
echo    " SPECIES (directory)"
echo -n $tag: "Copying:"
if [ ! -d $input_templates/SPECIES ] ; then
    echo
    echo $tag: "Required SPECIES directory not found: $input_templates/SPECIES"
    exit 11
fi
$exe_cmd cp $input_templates/SPECIES/* $flex_input/SPECIES

# Copy landuse file
$exe_cmd cp $landuse_file $flex_input

# Release with tag
if [[ -n $rel_tag ]] ; then
    rel_source=$input_templates/RELEASES.$rel_tag
else
    rel_source=$input_templates/RELEASES
fi
if [ ! -f $rel_source ] ; then
    echo
    echo $tag: "Required RELEASES file not found: $rel_source"
    exit 12
fi
[[ -z $exe_cmd ]] && echo -n " $(basename $rel_source)-->RELEASES,"
$exe_cmd cp $rel_source $flex_input/RELEASES
if (( $? != 0 )) ; then
    echo $tag: "Error copying RELEASES file, exiting."
    exit 13
fi

# Command
[[ -z $exe_cmd ]] && echo -n " COMMAND --> COMMAND,"
if [ -f $input_templates/COMMAND ] ; then
    $exe_cmd cp $input_templates/COMMAND $flex_input/COMMAND
else
    echo
    echo $tag: "Cannot find template:" \
	$input_templates/COMMAND
    exit 14
fi

# Outgrid
outgrid=OUTGRID.$resol
[[ -z $exe_cmd ]] && echo -n " $outgrid --> OUTGRID"
if [ -f $input_templates/$outgrid ] ; then
    $exe_cmd cp $input_templates/$outgrid $flex_input/OUTGRID
else
    echo
    echo "$tag: Cannot find template file for specified model resolution:" \
	$input_templates/$outgrid
    exit 15
fi
echo

# Output directory
if [ -d $flex_output ] ; then
    # Clean up output
    echo $tag: "Cleaning up output files in: $flex_output"
    $exe_cmd rm -f $flex_output/*
else
    # Create output directory
    echo $tag: "Creating output directory: $flex_output"
    $exe_cmd mkdir -p $flex_output
fi

# Adapt COMMAND
# -------------
echo $tag: "Adapting input file: $flex_input/COMMAND"
# Forward/backward mode
# Note: correct place to replace number is recognized by
# 4 leading and 4 trailing blanks
echo $tag: "  Forward/backward mode: $mode"
if [[ $mode == '-1' ]] ; then
    $exe_cmd gres '    1    ' '   -1    ' $flex_input/COMMAND
fi

# Beginning date/time
echo $tag: "  Beginning date/time: ${basetime:0:8} ${basetime:8:2}0000"
$exe_cmd gres "IBDATE *= *[0-9]*, !" \
    "IBDATE=         ${basetime:0:8}, !" \
    $flex_input/COMMAND
$exe_cmd gres "IBTIME *= *[0-9]*, !" \
    "IBTIME=           ${basetime:8:2}0000, !"\
    $flex_input/COMMAND
# Ending date/time
vt_str=( $(date +"%Y%m%d %H%M%S" --utc \
                --date="${basetime:0:8} ${basetime:8:2} ${fc_range} hours") )
echo $tag: "  Ending date/time: ${vt_str[*]}"
$exe_cmd gres "20160502 150000" "$vt_str" $flex_input/COMMAND
$exe_cmd gres "IEDATE *= *[0-9]*, !" \
    "IEDATE=         ${vt_str[0]}, !" \
    $flex_input/COMMAND
$exe_cmd gres "IETIME *= *[0-9]*, !" \
    "IETIME=           ${vt_str[1]}, !"\
    $flex_input/COMMAND
# Averaging and output interval
(( avg_s = $avg_h * 3600 ))
echo $tag: "  Averaging and output interval: $avg_s"
$exe_cmd gres "LOUTSTEP *= *[0-9]*, !" "$(printf "LOUTSTEP=%15d" $avg_s), !" \
    $flex_input/COMMAND
$exe_cmd gres "LOUTAVER *= *[0-9]*, !" "$(printf "LOUTAVER=%15d" $avg_s), !" \
    $flex_input/COMMAND
# Output format (-J, --iout)
$exe_cmd gres "IOUT *= *[0-9]*, !" "$(printf "IOUT=%15d" $iout), !" \
    $flex_input/COMMAND

# Adapt RELEASES
# -------------
echo $tag: Adapting input file: $flex_input/RELEASES
# Beginning date/time of release
echo $tag: "  Beginning date/time of release: ${release_start[*]}"
$exe_cmd gres "IDATE1 *=.*, !" \
    "IDATE1  =       ${release_start[0]}, !" \
    $flex_input/RELEASES
$exe_cmd gres "ITIME1 *=.*, !" \
    "ITIME1  =         ${release_start[1]}, !"\
    $flex_input/RELEASES
# Ending date/time of release
echo $tag: "  Ending date/time of release: ${release_end[*]}"
$exe_cmd gres "IDATE2 *=.*, !" \
    "IDATE2  =       ${release_end[0]}, !"\
    $flex_input/RELEASES
$exe_cmd gres "ITIME2 *=.*, !" \
    "ITIME2  =         ${release_end[1]}, !"\
    $flex_input/RELEASES
# Replace species number (option --species-no)
if [[ -n $species_no ]] ; then
    echo $tag: "      Species number: $species_no"
    $exe_cmd gres "SPECNUM_REL *=.*, !" " SPECNUM_REL = $species_no, !" \
	$flex_input/RELEASES
fi
# Replace total mass emitted (option --rel-mass)
if [[ -n $rel_mass ]] ; then
    echo $tag: "  Total mass emitted: $rel_mass"
    $exe_cmd gres "MASS *=.*, !" "MASS = $rel_mass, !" \
	$flex_input/RELEASES
fi

# Parallel execution
if [[ $run_mode == parallel ]] ; then
    parallel_opt='--ntasks=8'
fi

# Write plot info
# ---------------
if [[ -z $dry_run ]] ; then
    cat > $flex_output/$plot_info_file <<EOF
${basetime}
EOF
# Note: plot_info file for Lagranto as written by lagranto_[cf] namelist:
# (would need $(date --utc --date=${basetime:0:8}T${basetime:8:2} +"%F %R %Z") as time string)
#    cat > plot_info <<EOF
#
#Model base time:                            ${LM_YYYY}-${LM_MM}-${LM_DD} ${LM_ZZ}:00 UTC
#Model name:                                 $LM_NL_F_TTAG
#North pole longitude:                       $LM_NL_POLLONLM_F
#North pole latitude:                        $LM_NL_POLLATLM_F
#Start longitude:                            $LM_NL_STARTLON_TOT_F
#Start latitude:                             $LM_NL_STARTLAT_TOT_F
#Increment in longitudinal direction:        $LM_NL_DLONLM_F
#Increment in latitudinal direction:         $LM_NL_DLATLM_F
#Number of points in longitudinal direction: $LM_NL_IELM_F
#Number of points in latitudinal direction:  $LM_NL_JELM_F
#
#EOF
fi

# Write job file
# --------------
if [[ -z $dry_run ]] ; then
    # Job head
    cat > $start_location/$job_file <<EOF
#!/bin/bash
#SBATCH --job-name=FLEXP.$job_name
#SBATCH --output=$start_location/$job_out
#SBATCH --error=$start_location/$job_out
#SBATCH --partition=$partition
#SBATCH --time=4:00:00
#SBATCH $parallel_opt

# Initialization
ulimit -s unlimited

# Change to case directory
cd $start_location

# echo date and current limits
date
ulimit -a

# Run flexpart
# ------------
# Load needed environment
source FLEXPART.env

# Run FLEXPART in case directory
${srun_cmd} $parallel_opt ./$fp_exe $fp_opt
EOF

fi

# Add full command to logfile
logline="$0 $args # $job_name # $tag $basetime $fc_range $mode"
logline+=" --average=$avg_h --exe=$exe_path/$fp_exe --exe-tag=$exe_tag"
logline+=" --partition=$partition --resol=$resol"
logline+=" --species-no=$species_no"
logline+=" --rel-tag=$rel_tag --rel-mass=$rel_mass --rel-time=$t1,$t2"
logline+=" --job=$job_name --source-no=$source_no # (${source_desc% })"
if [[ -z $dry_run ]] ; then
    echo "$logline # $(date +%F\ %R)" >> $tag.log
fi

# Submit job
# ----------
if [[ -n $no_submit ]] ; then
    echo $tag: "Option -s set, job not submitted: $start_location/$job_file"
    exe_cmd="echo -e \033[07;32m \033[0m "
else
    echo $tag: "Submitting job: $start_location/$job_file"
    echo $tag: "  to partition: $partition"
    echo $tag: "Job output: $start_location/$job_out"
fi

$exe_cmd ${sbatch_cmd} $start_location/$job_file

# Report full command
echo $tag: "Completed command:"
echo "$logline"

exit
