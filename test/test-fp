#!/bin/bash
#+============================================================================
#
# Description:
#
#   Calculate dispersion using an IFS-HRES forecast
#   -----------------------------------------------
#
#   Checks files on disk and retrieves them from cache or store
#   Creates input and output directories for flexpart
#   Adapts input files for flexpart
#   Creates numbered job directory
#   Copies executable to job directory
#   Submits job on appropriate queue
#
# Author: Pirmin Kaufmann, MeteoSwiss
#
# Version:
  revision=1.6   #vincr# version number, may be incremented using vincr
#
# See git log for history of modifications
#-============================================================================

#=============================================================================
# Settings
#=============================================================================
# NWP model data sources
# ----------------------
# String is split at " in: "
# "<description> in: <path>"
# Path to GRIB files disp[cf]YYYYMMDDHH
# ECMWF IFS-HRES
nwp_source_list=( \
    "Operational cache global 3-hrly  in: /opr/osm/cache/LADM/FLEXPART-IFS-GLOBAL" \
    "Operational cache Europe 1-hrly  in: /opr/osm/cache/LADM/FLEXPART-IFS-EUROPE" \
    "Operational cache on escha/kesch in: /opr/owm/cache/FLEXPART-IFS"             \
    "User cache                       in: /scratch/$LOGNAME/FLEXPART-IFS"          \
    )
# Flexpart environment file
environment_file=$(dirname $PWD)/src/FLEXPART.env
# Flexpart input file templates
input_templates=$(dirname $PWD)/options # original options directory
#input_templates=$PWD/options # options directory in test
# Automatic job numbering
job_no_file=$HOME/.flexpart_job
# Root directory for job directories
job_root=$SCRATCH/flexpart/job
# Job file
job_file=job
# Job logfile
job_out=job.log
# Landuse file
landuse=/store/mch/msopr/flexpart_data/IGBP_int1.dat

# Defaults for arguments
# ----------------------
# Base time
basetime=$(date --utc --date="00" +%Y%m%d%H)           # Current day 00 UTC
# Forecast range
fc_range=72
# Simulation mode
mode=1
# Tag of RELEASES file
rel_tag=goe

# Defaults for options
# --------------------
# Resolution (-r, --resol)
resol=global
# Flexpart executable (-e, --exe-tag)
# should agree with Makefile variables EXEDIR, EXECUTABLE
exe_path=$(dirname $PWD)/src
fp_exe_serial=FLEXPART
fp_exe_parallel=FLEXPART_MPI
# Flexpart option (one of -v -v2 -i -i2) and argument (name of pathfile)
fp_opt=
# Release start and end (h, relative to basetime) (-t, --rel-time)
t1=0
t2=8
# Averaging interval and output frequency (-a, --average)
avg_h=3
# Species number
species_no=16 # Cs-137
# Total released mass (-m, --rel-mass)
rel_mass=1.0E09
# Run mode serial or parallel
run_mode=serial
# Partition (-p, --partition)
# On kesch/escha: one of postproc, pp-long, pp-serial
partition_serial=pp-serial
partition_parallel=postproc

#=============================================================================
# Functions
#=============================================================================
function version {
    # Print script name and revision number on stderr
    cat >&2 << EOF

$tag $revision

EOF
} # function version
#=============================================================================
function usage {
    # Show script usage
    cat >&2 << EOF

Script to prepare and run Flexpart

Usage: $tag [Options] [BASETIME FC_RANGE MODE TAG]

Arguments:

  BASETIME      forecast base date/time (format YYYYMMDDHH, def.: $basetime)
  FC_RANGE      maximum lead time / forecast range (def.: $fc_range)
  MODE          simulation mode: 1 = forward, -1 = backward (def.: $mode)
  TAG           use RELEASES.TAG as template for RELEASES file (def.: $rel_tag)

Options:
  Mandatory arguments to long options are mandatory for short options too.
  -a, --average=H      averaging interval and output freqency of H [hours]
                       (Default: $avg_h)
  -e, --exe-tag=TAG    executable tag, attach _TAG to name of executable
      --fp-opt=OPT     add option OPT to command line when starting FLEXPART
                       (Default: $fp_opt)
  -h, --help           show this help and exit
  -j, --job=NAME       manually set job name (default: consecutive number)
  -n, --dry-run        print commands without executing them
      --nwp-source=DIR directory with NWP files (precedence over --source-no)
      --parallel       run parallel code
  -p, --partition=P    partition, one of pp (=postproc), debug, normal, dev
  -r, --resol=RESOL    resolution, one of "global", "europe" (default: $resol)
  -m, --rel-mass=M     released mass [Bq] (default: $rel_mass)
  -t, --rel-time=T1,T2 release from T1 to T2 (lead times [hours]).
                       (Default: $t1,$t2)
      --run-mode=MODE  run code in MODE, either serial or parallel
  -S, --source-no=N    select source no N from list of NWP data sources
      --species-no=N   select species no N according to definition
                       in SPECIES directory
  -s, --stop           stop script before starting job (do not submit job)
  -V, --version        output version information and exit
  -x, --exe=EXE        Flexpart executable including path (default path:
                       $exe_path
                       default names: $fp_exe_serial for serial,
                       $fp_exe_parallel for parallel runs)

EOF
} # function usage

#=============================================================================
# Initialization
#=============================================================================
tag=$(basename $0)
args="$*"

#=============================================================================
# Parse options and arguments
#=============================================================================
iarg=0
while (( $# > 0 )) ; do
    case "$1" in
	-a | --average*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		avg_h="${1#*=}"
	    else
		(( $# > 1 )) && shift && avg_h="$1"
	    fi
	    ;;
	-e | --exe-tag*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		exe_tag="${1#*=}"
	    else
		(( $# > 1 )) && shift && exe_tag="$1"
	    fi
	    ;;
	-e | --fp-opt*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		fp_opt="${1#*=}"
	    else
		(( $# > 1 )) && shift && fp_opt="$1"
	    fi
	    ;;
	-h | --help)
	    usage
	    exit 0
	    ;;
	-j | --job*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		job_name="${1#*=}"
	    else
		(( $# > 1 )) && shift && job_name="$1"
	    fi
	    ;;
	-m | --rel-mass*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		rel_mass="${1#*=}"
	    else
		(( $# > 1 )) && shift && rel_mass="$1"
	    fi
	    ;;
	-n | --dry-run)
	    dry_run=yes
	    ;;
	--nwp-source*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		nwp_source="${1#*=}"
	    else
		(( $# > 1 )) && shift && nwp_source="$1"
	    fi
	    ;;
	-p | --partition*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		partition="${1#*=}"
	    else
		(( $# > 1 )) && shift && partition="$1"
	    fi
	    [[ $partition == pp ]] && partition=postproc
	    ;;
	-r | --resol*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		resol="${1#*=}"
	    else
		(( $# > 1 )) && shift && resol="$1"
	    fi
	    ;;
	--run-mode*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		run_mode="${1#*=}"
	    else
		(( $# > 1 )) && shift && run_mode="$1"
	    fi
	    ;;
	-s | --stop)
	    no_submit=yes
	    ;;
	--species-no*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		species_no="${1#*=}"
	    else
		(( $# > 1 )) && shift && species_no="$1"
	    fi
	    ;;
	-t | --rel-time*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		relt="${1#*=}"
		t1="${relt%,*}"
		t2="${relt#*,}"
	    else
		(( $# > 1 )) && shift && t1="$1"
		(( $# > 1 )) && shift && t2="$1"
	    fi
	    ;;
	-S | --source-no*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		source_no="${1#*=}"
	    else
		if (( $# > 1 )) ; then
		    shift
		    source_no="$1"
		else
		    echo $tag: "Missing value for option: --source-no"
		    exit 1
		fi
	    fi
	    ;;
	-V | --version)
	    version
	    exit 0
	    ;;
	-x | --exe*)
	    # Mandatory option argument with or without =
	    if [[ "$1" == *=* ]] ; then
		fn="${1#*=}"
		exe_path=$(dirname "$fn")
		fp_exe=$(basename "$fn")
	    else
		(( $# > 1 )) && shift && exe_path=$(dirname "$1") && fp_exe=$(basename "$1")
	    fi
	    ;;
	-*)
            echo $tag: "Unknown option $1"
	    exit 2
	    ;;
	*)
	    (( iarg++ ))
	    case $iarg in
		1)  # BASETIME
		    basetime="$1"
		    # Y2K compatibility for 2000 - 2099
		    [[ ${#basetime} == 8 ]] && basetime=20$basetime
		    ;;
		2)  # FC_RANGE
		    fc_range="$1"
		    ;;
		3)  # MODE
		    mode="$1"
		    ;;
		4)  # REL_TAG
		    rel_tag="$1"
		    ;;
		*)
		    echo $tag: "Too many arguments: $1"
		    exit 3
		    ;;
	    esac
	    ;;
    esac
    shift
done

#=============================================================================
# Start processing
#=============================================================================
# Option -n, --dry-run
if [[ -n $dry_run ]] ; then
    # Enable escape sequences in echo with option -e
    exe_cmd="echo -e \e[07;32m \e[0m  "
    echo    "$tag: INFO: Option --dry-run set, printing commands without executing them."
    echo -n "$tag: Skipped commands are marked with: "
    $exe_cmd
fi

# Job number
if [ -f $job_no_file ] ; then
    job_no=`cat $job_no_file`
else 
    job_no=0
fi
if [[ -z $job_name ]] ; then
    (( job_no++ ))
    if [[ -z $dry_run ]] ; then
	echo $job_no > $job_no_file
    fi
    job_name=$job_no
fi
echo $tag: "Job tag: $job_name"

# Resolution
# Define start of grib file name of mother and nested domains
case $resol in
    europe)
	# Operational configuration summer 2020, mother domain 0.1° Europe, no nest
	nests=( dispf )
	;;
    global)
	# Operational configuration summer 2020, IFS-HRES 0.5° global, 0.1° Europe
	nests=( dispc dispf )
	;;
    h1)
	# Obsolete configuration, IFS-HRES 1° global, 0.1° Europe
	nests=( dispc dispf )
	;;
    h05)
	# Operational configuration, IFS-HRES 0.5° global, 0.1° Europe
	nests=( dispc dispf )
	;;
    h01)
	# Test configuration, mother domain 0.1° Europe, no nest
	nests=( dispf )
	;;
    *)
	echo $tag: "Unknown resolution: $resol"
	exit 4
	;;
esac

# Option --partition
if [[ -z $partition ]] ; then
    # Default depends on run_mode
    eval partition=\$partition_$run_mode
fi

# Prepare job
# -----------
# Job directory
start_location=$job_root/$job_name
if [ -d $start_location ] ; then
    echo -n $tag: "Job directory already exists, overwrite? "
    read answer
    if [[ $answer != [yY]* ]] ; then
	echo $tag: "Aborted"
	exit 5
    fi
else
    $exe_cmd mkdir -p $start_location
fi
# Link working dir into test dir
$exe_cmd ln -sf $job_root .

# Executable
if [[ -z $fp_exe ]] ; then
    # Default depends on run_mode
    eval fp_exe=\$fp_exe_$run_mode
fi
if [[ -n $exe_tag ]] ; then
    fp_exe=${fp_exe}_$exe_tag
fi
if [ ! -x $exe_path/$fp_exe ] ; then
    echo $tag: "Executable not found: $exe_path/$fp_exe"
    exit 6
fi
# Copy executable and environmet file
$exe_cmd cp -p $exe_path/$fp_exe $start_location/.
$exe_cmd ln -sf $exe_path $start_location/.
$exe_cmd cp $environment_file $start_location/.

# Input and output directories
flex_input=$start_location/input
flex_output=$start_location/output

# Create pathnames file
echo $tag: "Creating input file: $start_location/pathnames"
# pathnames: directories must have slash at end!
# file must contain empty line at end!
if [[ -z $dry_run ]] ; then
    cat > $start_location/pathnames <<EOF
$flex_input/
$flex_output/
EOF
fi

# Ajust release time and duration
if ! [[ $t1 =~ ^[0-9]+$ ]] ; then
    echo $tag: "Release time 1 not valid: >$t1<"
    exit 7
fi
if ! [[ $t2 =~ ^[0-9]+$ ]] ; then
    echo $tag: "Release time 2 not valid: $t2"
    exit 8
fi

(( $t1 < 0 )) && (( t1 = 0 ))
(( $t1 > $fc_range )) && (( t1 = $fc_range ))
(( $t2 <= $t1 )) && echo $tag: "Error: Release end before release start: $t2 < $t1"
(( $t2 > $fc_range )) && (( t2 = $fc_range ))

# Release start and end date/times
release_start=( $(date --utc +"%Y%m%d %H%M%S" \
	               --date="${basetime:0:8} ${basetime:8:2} $t1 hours") )
  release_end=( $(date --utc +"%Y%m%d %H%M%S" \
	               --date="${basetime:0:8} ${basetime:8:2} $t2 hours") )

# Retrieve input data
# -------------------

# Select NWP data source
# ----------------------
if [[ -z $nwp_source ]] ; then
    if [[ -z $source_no ]] ; then
	echo "Select NWP data source (option --source-no)"
	select answer in "${nwp_source_list[@]}" ; do
	    # Note: Press return for default not possible
	    # as select repeats prompt until REPLY is not empty
	    [[ $REPLY == quit || $REPLY == exit ]] && exit
	    # answer is only set if REPLY was valid
	    [[ -n $answer ]] && break
	done
	source_no=$REPLY
	echo "You secected: $answer"
    else
	(( i_source = $source_no - 1 ))
	answer=${nwp_source_list[$i_source]}
	echo "Selected data source: $answer"
    fi

    # Extract directory path from nwp_source_list entry
    nwp_source=${answer#* in: }
    source_desc=${answer%% in:*}
else
    source_desc=$nwp_source
fi

# Check if GRIB data available
if [ ! -d $nwp_source ] ; then
    echo "$tag: NWP source is not a directory: $nwp_source"
    exit 9
fi

# Link destination for NWP files
grib_input=$start_location/grib

# Report GRIB data directory
echo $tag: "Model data source: $nwp_source"
echo $tag: "Supplying model data for FLEXPART in: $grib_input"

# Create input directory, including SPECIES subdirectory
echo $tag: "Creating flexpart input directory: $flex_input"
$exe_cmd mkdir -p $flex_input/SPECIES

# Link GRIB directory into job dir
# Option -T (--no-target-directory) enforces recreation
# of the last operand even if it is a directory
$exe_cmd ln -sfT $nwp_source $grib_input

# Create AVAILABLE files
# Loop over nests
i_nest=0
while (( $i_nest < ${#nests[*]} )) ; do
    nest=${nests[$i_nest]}
    if (( $i_nest < 1 )) ; then
	available_filename=AVAILABLE
    elif (( $i_nest < 2 )) ; then
	available_filename=AVAILABLE_NEST
    else
	available_filename=AVAILABLE_NEST$i_nest
    fi
    if [[ -n $dry_run ]] ; then
	available_file=$(tty)
    else
	available_file=$flex_input/$available_filename
    fi
    # Write file header
    echo $tag: "Creating AVAILABLE file with $nest* files for nest $i_nest: $available_file"
    cat > $available_file << EOF
DATE     TIME        FILENAME
YYYYMMDD HHMISS 
________ ______      __________________
EOF

    # Find grib files
    if [ -d $grib_input ] ; then
	pushd $grib_input > /dev/null
	gribfiles=( $nest* )
	if [ ! -e "${gribfiles[0]}" ] ; then
	    echo $tag: "No $nest* files found in: $grib_input"
	    unset gribfiles
	fi
	popd > /dev/null
    else
	echo $tag: "No such directory: $grib_input"
	unset gribfiles
    fi
    # Loop over existing files
    for grib_file in ${gribfiles[*]} ; do
	printf "%s %s0000      %s\n" \
	    ${grib_file:5:8} ${grib_file:13:2} $grib_file >> \
	    $available_file
    done

    # Create pathnames file, entry for each nest
    # pathnames: directories must have slash at end!
    if [[ -z $dry_run ]] ; then
	cat >> $start_location/pathnames <<EOF
$grib_input/
$available_file
EOF

	(( i_nest++ ))
    fi
done # Loop over nests

# Write end of pathnames
if [[ -z $dry_run ]] ; then
    cat >> $start_location/pathnames <<EOF
============================================

EOF
fi

# Create input directory with SPECIES subdirectory
echo $tag: "Creating input directory: $flex_input"
$exe_cmd mkdir -p $flex_input/SPECIES

# Copy input files
echo $tag: "Copying input files from: ${input_templates}"
echo -n $tag: "Copying:"
for f in AGECLASSES RECEPTORS \
	    surfdata.t surfdepo.t ; do
    echo -n " $f,"
    if [ ! -f $input_templates/$f ] ; then
	echo
	echo $tag: "Cannot find template file:" \
	    $input_templates/$f
	exit 10	
    fi
    $exe_cmd cp $input_templates/$f $flex_input
done
echo    " SPECIES (directory)"
echo -n $tag: "Copying:"
if [ ! -d $input_templates/SPECIES ] ; then
    echo
    echo $tag: "Required SPECIES directory not found: $input_templates/SPECIES"
    exit 11
fi
$exe_cmd cp $input_templates/SPECIES/* $flex_input/SPECIES

# Copy landuse file
$exe_cmd cp $landuse $flex_input

# Release with tag
if [[ -n $rel_tag ]] ; then
    rel_source=$input_templates/RELEASES.$rel_tag
else
    rel_source=$input_templates/RELEASES
fi
if [ ! -f $rel_source ] ; then
    echo
    echo $tag: "Required RELEASES file not found: $rel_source"
    exit 12
fi
[[ -z $exe_cmd ]] && echo -n " $(basename $rel_source)-->RELEASES,"
$exe_cmd cp $rel_source $flex_input/RELEASES
if (( $? != 0 )) ; then
    echo $tag: "Error copying RELEASES file, exiting."
    exit 13
fi

# Command
[[ -z $exe_cmd ]] && echo -n " COMMAND --> COMMAND,"
if [ -f $input_templates/COMMAND ] ; then
    $exe_cmd cp $input_templates/COMMAND $flex_input/COMMAND
else
    echo
    echo $tag: "Cannot find template:" \
	$input_templates/COMMAND
    exit 14
fi

# Outgrid
outgrid=OUTGRID.$resol
[[ -z $exe_cmd ]] && echo -n " $outgrid --> OUTGRID"
if [ -f $input_templates/$outgrid ] ; then
    $exe_cmd cp $input_templates/$outgrid $flex_input/OUTGRID
else
    echo
    echo "$tag: Cannot find template file for specified model resolution:" \
	$input_templates/$outgrid
    exit 15
fi
echo

# Output directory
if [ -d $flex_output ] ; then
    # Clean up output
    echo $tag: "Cleaning up output files in: $flex_output"
    $exe_cmd rm -f $flex_output/*
else
    # Create output directory
    echo $tag: "Creating output directory: $flex_output"
    $exe_cmd mkdir -p $flex_output
fi

# Adapt COMMAND
# -------------
echo $tag: "Adapting input file: $flex_input/COMMAND"
# Forward/backward mode
# Note: correct place to replace number is recognized by
# 4 leading and 4 trailing blanks
echo $tag: "  Forward/backward mode: $mode"
if [[ $mode == '-1' ]] ; then
    $exe_cmd gres '    1    ' '   -1    ' $flex_input/COMMAND
fi

# Beginning date/time
echo $tag: "  Beginning date/time: ${basetime:0:8} ${basetime:8:2}0000"
$exe_cmd gres "IBDATE *= *[0-9]*, !" \
    "IBDATE=         ${basetime:0:8}, !" \
    $flex_input/COMMAND
$exe_cmd gres "IBTIME *= *[0-9]*, !" \
    "IBTIME=           ${basetime:8:2}0000, !"\
    $flex_input/COMMAND
# Ending date/time
vt_str=( $(date +"%Y%m%d %H%M%S" --utc \
                --date="${basetime:0:8} ${basetime:8:2} ${fc_range} hours") )
echo $tag: "  Ending date/time: ${vt_str[*]}"
$exe_cmd gres "20160502 150000" "$vt_str" $flex_input/COMMAND
$exe_cmd gres "IEDATE *= *[0-9]*, !" \
    "IEDATE=         ${vt_str[0]}, !" \
    $flex_input/COMMAND
$exe_cmd gres "IETIME *= *[0-9]*, !" \
    "IETIME=           ${vt_str[1]}, !"\
    $flex_input/COMMAND
# Averaging and output interval
(( avg_s = $avg_h * 3600 ))
echo $tag: "  Averaging and output interval: $avg_s"
$exe_cmd gres "LOUTSTEP *= *[0-9]*, !" "$(printf "LOUTSTEP=%15d" $avg_s), !" \
    $flex_input/COMMAND
$exe_cmd gres "LOUTAVER *= *[0-9]*, !" "$(printf "LOUTAVER=%15d" $avg_s), !" \
    $flex_input/COMMAND

# Adapt RELEASES
# -------------
echo $tag: Adapting input file: $flex_input/RELEASES
# Beginning date/time of release
echo $tag: "  Beginning date/time of release: ${release_start[*]}"
$exe_cmd gres "IDATE1 *=.*, !" \
    "IDATE1  =       ${release_start[0]}, !" \
    $flex_input/RELEASES
$exe_cmd gres "ITIME1 *=.*, !" \
    "ITIME1  =         ${release_start[1]}, !"\
    $flex_input/RELEASES
# Ending date/time of release
echo $tag: "  Ending date/time of release: ${release_end[*]}"
$exe_cmd gres "IDATE2 *=.*, !" \
    "IDATE2  =       ${release_end[0]}, !"\
    $flex_input/RELEASES
$exe_cmd gres "ITIME2 *=.*, !" \
    "ITIME2  =         ${release_end[1]}, !"\
    $flex_input/RELEASES
# Species number
echo $tag: "      Species number: $(printf "%9.3E" $species_no)"
$exe_cmd gres "SPECNUM_REL *=.*, !" " SPECNUM_REL=$(printf "%11d" $species_no), !" \
    $flex_input/RELEASES
# Total mass emitted
echo $tag: "  Total mass emitted: $(printf "%9.3E" $rel_mass)"
$exe_cmd gres "MASS *=.*, !" "MASS    =$(printf "%15.4E" $rel_mass), !" \
    $flex_input/RELEASES

# Parallel execution
if [[ $run_mode == parallel ]] ; then
    parallel_opt='--ntasks=8'
fi

# Write job file
# --------------
if [[ -z $dry_run ]] ; then
    # Job head
    cat > $start_location/$job_file <<EOF
#!/bin/bash
#SBATCH --job-name=FP.$job_name
#SBATCH --output=$start_location/$job_out
#SBATCH --error=$start_location/$job_out
#SBATCH --partition=$partition
#SBATCH --time=4:00:00
#SBATCH $parallel_opt

# Initialization
ulimit -s unlimited

# Change to case directory
cd $start_location

# echo date and current limits
date
ulimit -a

# Run flexpart
# ------------
# Load needed environment
source FLEXPART.env

# Run FLEXPART in case directory
srun --kill-on-bad-exit $parallel_opt ./$fp_exe $fp_opt
EOF

fi

# Add full command to logfile
logline="$0 $args # $job_name # $tag $basetime $fc_range $mode $rel_tag"
logline="$logline --average=$avg_h --exe=$exe_path/$fp_exe --exe-tag=$exe_tag --partition=$partition --resol=$resol"
logline="$logline --rel-mass=$rel_mass --rel-time=$t1,$t2 --job=$job_name --source-no=$source_no --nwp-source=$nwp_source"
if [[ -z $dry_run ]] ; then
    echo "$logline # $(date +%F\ %R)" >> $tag.log
fi

# Submit job
# ----------
if [[ -n $no_submit ]] ; then
    echo $tag: "Option -s set, job not submitted: $start_location/$job_file"
    exe_cmd="echo -e \033[07;32m \033[0m "
else
    echo $tag: "Submitting job: $start_location/$job_file"
    echo $tag: "Job output: $start_location/$job_out"
fi

$exe_cmd sbatch $start_location/$job_file

# Report full command
echo $tag: "Completed command:"
echo "$logline"

exit
